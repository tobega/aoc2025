composer parse-instructions
  <left|right>
  rule left: (<='L'>) <INT "L">
  rule right: (<='R'>) <INT "R">
end parse-instructions
    
def instructions: [$IN::lines -> parse-instructions];

templates part1
  sink update-zeroes
    when <=0"1"> do
      @part1(zeroes:): $@part1(zeroes:) + 1"1";
  end update-zeroes
  @: { zeroes: 0"1", position: 50"1"};
  $... -> #
  $@(zeroes:) !

  when <"L"> do
    @(position:): ($@(position:) - $)"1" mod 100"1";
    $@(position:) -> !update-zeroes
  when <"R"> do
    @(position:): ($@(position:) + $)"1" mod 100"1";
    $@(position:) -> !update-zeroes
end part1

templates part2
  sink update-zeroes
    when <..0"1"> do
      @part2(zeroes:): $@part2(zeroes:) - $ ~/ 100"1" + 1"1";
    when <100"1"..> do
      @part2(zeroes:): $@part2(zeroes:) + $ ~/ 100"1";
  end update-zeroes
  @: { zeroes: 0"1", position: 50"1"};
  $... -> #
  $@(zeroes:) !

  when <"L"?($@(position:) <=0"1">)> do
    def new: ($@(position:) - $)"1";
    // Don't double-count the zero
    @:  {position: $new mod 100"1", zeroes: $@(zeroes:) - 1"1"};
    $new -> !update-zeroes
  when <"L"> do
    def new: ($@(position:) - $)"1";
    @(position:):  $new mod 100"1";
    $new -> !update-zeroes
  when <"R"> do
    def new: ($@(position:) + $)"1";
    @(position:): $new mod 100"1";
    $new -> !update-zeroes
end part2

$instructions -> part1 -> !OUT::write
'
' -> !OUT::write

$instructions -> part2 -> !OUT::write
'
' -> !OUT::write
