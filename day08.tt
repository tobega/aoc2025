composer parse-box
  [<INT>, (<=','>) <INT>, (<=','>) <INT>]
end parse-box

def boxes: [$IN::lines -> parse-box];

// A max heap for k elements in k-select (which will select the k smallest elements)
// in v0.5, a transform in on: should allow using as min heap, meanwhile transform first
processor Heap&{k:, on:}
  @:[];

  source get-unsorted
    $@Heap !
  end get-unsorted

  sink bubble-up
    def child: $;
    def parent: $ ~/ 2;
    $child -> \(when <1~..> do $@Heap($child; on) ! \) -> #

    when <$@Heap($parent; on)~..> do
      @Heap([$child, $parent]): $@Heap([$parent, $child])...;
      $parent -> !bubble-up
  end bubble-up

  sink trickle-down
    def left: $ * 2;
    def right: $left + 1;
    $ -> #

    when <?($right <..$@Heap::last>)
    ?($@Heap($right; on) <$@Heap($left; on)~..>)
    ?($@Heap($right; on) <$@Heap($; on)~..>)> do
      @Heap([$, $right]): $@Heap([$right, $])...;
      $right -> !trickle-down
    
    when <?($left <..$@Heap::last>)
    ?($@Heap($left; on) <$@Heap($; on)~..>)> do
      @Heap([$, $left]): $@Heap([$left, $])...;
      $left -> !trickle-down
  end trickle-down

  templates insert
    when <?($k::raw <=0>)|?($@Heap::length <..~$k::raw>)> do
      ..|@Heap: $;
      $@Heap::last -> !bubble-up
    
    when <?($(on) <..~$@Heap(1; on)>)> do
      def discarded: $@Heap(1);
      @Heap(1): $;
      1 -> !trickle-down
      $discarded !
    
    otherwise
      $ !
  end insert

  source pop
    def result: $@Heap(1);
    @Heap(1): ^@Heap(last);
    1 -> !trickle-down
    $result !
  end pop
end Heap

test 'K-select'
  def heap: $Heap&{k: 3, on: :(age:)};
  assert [[{name: 'Alice', age: 3},
   {name: 'Bob', age: 66},
   {name: 'Debra', age: 9},
   {name: 'Eva', age: 11},
   {name: 'Charlie', age: 15},
   {name: 'Frank', age: 5}]... -> heap::insert]
   <=[{name: 'Bob', age: 66}, {name: 'Charlie', age: 15}, {name: 'Eva', age: 11}]> 'outputs discarded'

  assert $heap::get-unsorted <[<{name: <='Debra'>}>, <{name: <='Alice'>}>, <{name: <='Frank'>}>](3)> 'has exactly all expected'

  assert $heap::pop <={name: 'Debra', age: 9}> 'pops largest of the smallest'
  assert $heap::get-unsorted <[<{name: <='Alice'>}>, <{name: <='Frank'>}>](2)> 'popped is removed'
end 'K-select'

test 'Max Heap'
  def heap: $Heap&{k: 0, on: :()};
  assert [1..2000 -> heap::insert] <=[]> 'none discarded'
  assert $heap::get-unsorted -> $::length <=2000> 'all are kept'
  assert $heap::pop <=2000> 'pops largest'
end 'Max Heap'

data element <..>
data elements <[<element>+ VOID]>
processor Disjoint-Sets
  @: [1..$];

  templates find
    when <=$@Disjoint-Sets($::raw)> do
      $!
    otherwise
      // store it back for path-contraction
      def set: $@Disjoint-Sets($::raw) -> #;
      @Disjoint-Sets($::raw): $set;
      $set !
  end find

  operator (a union b)
    def a-set: $a::raw -> find;
    def b-set: $b::raw -> find;
    @Disjoint-Sets($a-set): $b-set;
  end union

  source get-sets
    [$@Disjoint-Sets::first..$@Disjoint-Sets::last -> {element: $, set: $ -> find}]
     -> $(collect {elements: List&{of: :(element:)}} by $({set:})) !
  end get-sets
end Disjoint-Sets

test 'Disjoint-Sets'
  def ds: 9 -> Disjoint-Sets;
  assert 5 -> ds::find <=5> 'identity'

  (3 ds::union 7) -> !VOID
  assert 3 -> ds::find <=0+(7 -> ds::find)> 'joined'

  (8 ds::union 9) -> !VOID
  (1 ds::union 9) -> !VOID
  (4 ds::union 3) -> !VOID
  assert $ds::get-sets <[
    <{set: <=2> elements: <[<=element´2>](1)>}>,
    <{set: <=5> elements: <[<=element´5>](1)>}>,
    <{set: <=6> elements: <[<=element´6>](1)>}>,
    <{set: <=3|=4|=7> elements: <[<=element´3>, <=element´4>, <=element´7>](3)>}>,
    <{set: <=1|=8|=9> elements: <[<=element´1>, <=element´8>, <=element´9>](3)>}>
  ]> 'get-sets'

  (9 ds::union 4) -> !VOID
  assert 8 -> ds::find <=0+(7 -> ds::find)> 'groups joined'
end 'Disjoint-Sets'

def sets: $boxes::length -> Disjoint-Sets;
def remainder: $Heap&{k: 0, on: :(neg-dist:)};

source part1
  def coords: $boxes;

  def min1000: $Heap&{k: 1000, on: :(distance:)};
  1..~$coords::last -> \(
    def i: $;
    $i~..$coords::last -> \(
        def j: $;
        1..3 -> ($coords($i; $) - $coords($j; $))"s" -> ($*$)"s2" -> ..=Sum&{of: :()}
        -> { from: box´$i, to: box´$j, distance: $} !
    \) !
  \) -> min1000::insert -> $({from:, to:, neg-dist: -§(distance:)}) -> !remainder::insert

  $min1000::get-unsorted ... -> ($(from:) sets::union $(to:)) -> !VOID

  def maxheap: $Heap&{k: 0, on: :(size:)};
  $sets::get-sets ... -> $({set:, size: §(elements:)::length}) -> !maxheap::insert
  ($maxheap::pop -> $(size:)::raw) * ($maxheap::pop -> $(size:)::raw) * ($maxheap::pop -> $(size:)::raw) !
end part1

$part1 -> !OUT::write
'
' -> !OUT::write

source part2
  $sets::get-sets -> $::length -> #
  $boxes($@(from:)::raw; 1) * $boxes($@(to:)::raw; 1) !

  when <1~..> do
    @: $remainder::pop;
    $@ -> ($(from:) sets::union $(to:)) -> !VOID
    $sets::get-sets -> $::length -> #
end part2

$part2 -> !OUT::write
'
' -> !OUT::write
